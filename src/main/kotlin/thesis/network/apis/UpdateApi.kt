/**
 * DRP
 * This is the thesis.main server of QLM's DRP system
 *
 * OpenAPI spec version: 1.0.0
 * Contact: akos.hollo-szabo@qlndc.hu
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package thesis.network.apis

import io.ktor.application.call
import io.ktor.http.*
import io.ktor.locations.*
import io.ktor.response.*
import io.ktor.routing.*
import thesis.logic.OAlgorithmManager
import thesis.model.mtsp.*
import thesis.utility.PolylineEncoder
import thesis.utility.requestRoot
import thesis.network.Paths
import java.math.BigDecimal
import java.util.*

// ktor 0.9.x is missing io.ktor.locations.DELETE, this adds it.
// see https://github.com/ktorio/ktor/issues/288

@KtorExperimentalLocationsAPI
fun Route.UpdateApi() {

    get<Paths.getProgress> {
        call.respond(
            HttpStatusCode.OK,
            OAlgorithmManager.algorithm?.let {
                DProgress(
                    UUID.randomUUID().toString(),
                    "placeholder",
                    it.iteration.toBigDecimal(),
                    BigDecimal(it.runTime_Second)
                )
            } ?: throw Exception("Algorithm should not be null")
        )
    }


    get<Paths.getResult> {
        call.respond(
            HttpStatusCode.OK,
            OAlgorithmManager.calcResult()
        )
    }

    get<Paths.getRoutBetween> {
        var response = requestRoot(
            call.parameters["fromLat"]?.toDouble() ?: throw Error("fromLat should not be null"),
            call.parameters["fromLong"]?.toDouble() ?: throw Error("fromLong should not be null"),
            call.parameters["toLat"]?.toDouble() ?: throw Error("toLat should not be null"),
            call.parameters["toLong"]?.toDouble() ?: throw Error("toLong should not be null")
        )

        repeat(10) {
            if (response.plan?.itineraries?.get(0)?.legs?.get(0)?.legGeometry?.points == null) {
                response = requestRoot(
                    call.parameters["fromLat"]?.toDouble() ?: throw Error("fromLat should not be null"),
                    call.parameters["fromLong"]?.toDouble() ?: throw Error("fromLong should not be null"),
                    call.parameters["toLat"]?.toDouble() ?: throw Error("toLat should not be null"),
                    call.parameters["toLong"]?.toDouble() ?: throw Error("toLong should not be null")
                )
            }
        }

        response.plan?.itineraries?.get(0)?.legs?.get(0)?.let { leg ->
            leg.legGeometry?.points?.let { points ->
                leg.distance?.let { distance ->
                    call.respond(
                        HttpStatusCode.OK,
                        DEdge(
                            UUID.randomUUID().toString(),
                            "",
                            0,
                            BigDecimal(distance),
                            rout = PolylineEncoder.decode(points).toTypedArray()
                        )
                    )
                }
            }
        } ?: call.respond(HttpStatusCode.MethodNotAllowed)

    }

}
